%% ------------------------------------------------------------------------- %%
\section{Algoritmos}
\label{sec:algoritmos}

A detecção da \emph{Frequência Fundamental (F0)} ou transcrição melódica é um problema bastante pesquisado e comumente considerado ``resolvido'' no caso de vozes ou instrumentos monofônicos gravados segundo \cite{de2001efficient}.
Porém a questão do tempo real adiciona algumas dificuldades ao problema. Geralmente esses são os requerimentos para os algoritmos em tempo real:

\begin{itemize}
\item Capacidade de funcionar em tempo real
\item Mínimo atraso de saída (latência)
\item Acurácia na presença de ruído
\item Sensibilidade à performance musical
\end{itemize}

Nesse contexto, apresentamos os seguintes algoritmos a serem implementados no \emph{ASyMuT - Automatic System for Music Transcription}:

\begin{itemize}
\item \emph{Harmonic Product Spectrum}
\item \emph{Maximum Likelihood}
\item \emph{Cepstrum-Biased Harmonic Product Spectrum}
\item \emph{Weighted Autocorrelation Function}
\end{itemize}

\subsection{Harmonic Product Spectrum - Espectro do Produto Harmônico}

Esse algoritmo busca por uma frequência cujo produto da magnitude dos primeiros $K$ harmônicos é máximo, calculando a seguinte função para cada frequência: $$Y(\omega) = \prod _{k=1}^{K} \abs{X(\omega k))}$$
E então buscando seu máximo: $$\widehat{Y} = \max\limits_{\omega_i}\{Y(\omega_i)\}$$
Um exemplo pode ser visto na figura \ref{fig:hps2}.

     \begin{figure}%[!htb]
\centering
\includegraphics[width=0.85\linewidth]{hps2.png}
\caption{Harmonic Product Spectrum para $K=5$}
\label{fig:hps2}
\end{figure}

\subsection{Maximum Likelihood - Máxima Verossimilhança}

Esse algoritmo busca por um conjunto de possíveis espectros ideais e escolhe aquele que melhor combina com o formato do espectro de entrada. O espectro ideal é definido como um trem de pulsos começando na frequência $\omega$ convoluído com o espectro da janela do sinal e pode ser visto na figura \ref{fig:maxver}.

     \begin{figure}%[!htb]
\centering
\includegraphics[width=0.6\linewidth]{maxver.png}
\caption{Geração de um espectro ideal.}
\label{fig:maxver}
\end{figure}

Esse processo tenta minimizar o erro entre o espectro da janela e os possíveis espectros candidatos, como ilustrado nas seguintes equações:

$$E(\omega) = \norm{ Y - \tilde{Y}_\omega}^{2}$$

$$= \norm{Y}^{2} + \norm{\tilde{Y}_\omega}^{2} - 2Y\tilde{Y}_\omega^{T}$$


\subsection{Cepstrum-Biased Harmonic Product Spectrum - Espectro do Produto Harmônico baseado no Cepstro}

\cite{master2000speech} Seção 1.3.1

\subsection{Weighted Autocorrelation Function - Função de autocorrelação ponderada}

Esse algoritmo busca por picos na função de autocorrelação (\emph{ACF}), ou seja, a função que relaciona o sinal com ele próprio, dada pela equação:

$$\phi(\tau) = \frac{1}{N}\sum_{n=0}^{N-1}x(n)x(n+\tau)$$

Tal equação mede o quanto um sinal correlaciona com um deslocamento temporal de $\tau$ de si mesmo.
Como um sinal periódico irá ter uma grande correlação com seu sinal deslocado pelo seu período, esperamos encontrar picos na função neste valor.

Uma alternativa à ACF é a Função de Média de Diferença em Magnitude (\emph{AMDF}). A AMDF busca pela a diferença entre o sinal original e o sinal deslocado ao invés do produto. Assim, esperamos encontrar vales na AMDF onde encontramos picos na ACF. O cálculo da AMDF é menos intensivo computacionalmente devido à ausência de operações de multiplicação.
Sua equação é a seguinte:

$$\psi(\tau) = \frac{1}{N}\sum_{n=0}^{N-1}  \left | x(n)-x(n+\tau) \right |$$


\cite{kobayashi2000weighted} mostraram que essas funções tem estatísticas diferentes e que podem ser combinadas para produzir uma estimativa mais robusta da frequência. A função descrita pelos autores é a seguinte:
$$f(\tau) = \frac{\phi(\tau)}{\psi(\tau)+k}$$
onde os resultados ótimos foram encontrados com k=1, independentemente da razão sinal-ruído (\emph{SNR}). Esse método mostrou ser mais efetivo em ambientes ruidosos do que a ACF,a AMDF e a técnica Cepstral mostrada anteriormente.

%Introduzir os algoritmos que serão melhor explicados no desenvolvimento.
%\begin{itemize}
%\item Explicar os algoritmos utilizados pelo ASyMuT
%\item Dar detalhes da parte matemática dos algoritmos implementados
%\end{itemize}
